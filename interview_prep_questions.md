### Interview Question and Answer Preparation (News Portal Project)

এই প্রজেক্টের ওপর ভিত্তি করে ইন্টারভিউতে সম্ভাব্য গভীর (Deep) প্রশ্ন এবং তাদের উত্তর নিচে দেওয়া হলো:

---

### ১. কেন আপনি Redis এবং MongoDB উভয়ই ব্যবহার করেছেন? View count ম্যানেজমেন্টের জন্য আপনার আর্কিটেকচারটি ব্যাখ্যা করুন।

**প্রশ্ন:** আপনি দেখছি Redis ব্যবহার করছেন `viewCount` ট্র্যাক করার জন্য, আবার MongoDB-তেও এটি সেভ করছেন। কেন সরাসরি MongoDB-তে আপডেট করছেন না?

**উত্তর:** 
সরাসরি MongoDB-তে প্রতিবার ভিউ আপডেট করলে ডাটাবেসের ওপর অনেক চাপ পড়ে (Write Heavy Operation), বিশেষ করে যখন ট্রাফিক বেশি থাকে। এটি পারফরম্যান্স কমিয়ে দেয়। 
আমার আর্কিটেকচারটি হলো:
- যখনই কেউ আর্টিকেল পড়ে, `CacheService.incrementView` এর মাধ্যমে Redis-এ ভিউ সংখ্যা বাড়ানো হয় (যা অত্যন্ত দ্রুত)।
- একটি ব্যাকগ্রাউন্ড জব (`viewSyncJob.js`) প্রতি ৫ মিনিট পরপর চলে।
- এই জবটি Redis থেকে ডাটা নিয়ে একবারেই (Bulk Update) MongoDB-তে সিঙ্ক করে।
এতে ডাটাবেসের `Write` অপারেশন কমে যায় এবং অ্যাপ্লিকেশনের স্কেলেবিলিটি বাড়ে।

---

### ২. Cache Invalidation বা ক্যাশ ডিলিট করার স্ট্র্যাটেজি কী?

**প্রশ্ন:** আপনি যখন কোনো আর্টিকেল আপডেট বা ডিলিট করেন, তখন ক্যাশ ডাটার কী হয়? আপনি কীভাবে নিশ্চিত করেন যে ইউজার সবসময় লেটেস্ট ডাটা দেখছে?

**উত্তর:** 
আমি `ArticleService.js` এ `invalidateListCaches()` মেথড ব্যবহার করেছি। 
- যখনই নতুন আর্টিকেল তৈরি হয়, আপডেট হয় বা ডিলিট হয়, আমি সাথে সাথে হোম পেজের ক্যাশ (`home_data`) এবং লিস্ট ক্যাশগুলো (`articles_list:*`) ডিলিট করে দিই। 
- আর্টিকেলের ক্ষেত্রে নির্দিষ্ট `slug` অনুযায়ী ক্যাশ ডিলিট করা হয়। 
- ক্যাশ ডিলিট করার পর পরবর্তী রিকোয়েস্টে সিস্টেম সরাসরি ডাটাবেস থেকে নতুন ডাটা নিয়ে আসে এবং ক্যাশ আবার আপডেট করে। একে **Write-Through/Cache-Aside** প্যাটার্ন বলা হয়।

---

### ৩. MongoDB ইনডেক্সিং (Indexing) নিয়ে আপনার চিন্তাভাবনা কী?

**প্রশ্ন:** `Article.js` মডেলে আপনি অনেকগুলো ইনডেক্স ব্যবহার করেছেন। এগুলোর প্রয়োজনীয়তা কী?

**উত্তর:** 
ডাটাবেস কুয়েরি দ্রুত করার জন্য ইনডেক্সিং অপরিহার্য। এই প্রজেক্টে:
- `slug` এর ওপর ইউনিক ইনডেক্স দেওয়া হয়েছে দ্রুত আর্টিকেল খোঁজার জন্য।
- `categoryId`, `status`, `isDeleted`, এবং `publishedAt` মিলিয়ে **Compound Index** ব্যবহার করা হয়েছে। কারণ ফিল্টার করার সময় আমরা সাধারণত ক্যাটাগরি এবং স্ট্যাটাস (Published) চেক করি এবং তারিখ অনুযায়ী সর্ট করি।
ইনডেক্স ছাড়া লক্ষ লক্ষ ডাটার মধ্যে কুয়েরি করলে তা অত্যন্ত ধীর হয়ে যাবে।

---

### ৪. Repository Pattern ব্যবহারের সুবিধা কী?

**প্রশ্ন:** আপনি সরাসরি Controller থেকে Mongoose মডেল ব্যবহার না করে Repository কেন ব্যবহার করেছেন?

**উত্তর:** 
এটি **Separation of Concerns** নিশ্চিত করে। 
- **Modularity:** ডাটাবেস লজিক এবং বিজনেস লজিক আলাদা থাকে। 
- **Testability:** আমরা চাইলে সহজেই ডাটাবেস অংশটি মক (Mock) করে বিজনেস লজিক টেস্ট করতে পারি।
- **Maintainability:** ভবিষ্যতে যদি Mongoose এর পরিবর্তে অন্য কোনো ORM বা ডাটাবেস ব্যবহার করতে হয়, তবে শুধু Repository ফাইলগুলো পরিবর্তন করলেই হবে, পুরো সার্ভিস লেয়ার হাত দেওয়ার প্রয়োজন পড়বে না।

---

### ৫. Error Handling আপনি কীভাবে ম্যানেজ করেছেন?

**প্রশ্ন:** আপনার প্রজেক্টে সেন্ট্রাল কোনো এরর হ্যান্ডলিং সিস্টেম আছে কি?

**উত্তর:** 
হ্যাঁ, আমি `errorMiddleware.js` ব্যবহার করেছি।
- সব এরর একটি কমন ফরম্যাটে ইউজারের কাছে যায় (Message এবং Stack Trace)।
- প্রোডাকশন এনভায়রনমেন্টে সিকিউরিটির জন্য `stack trace` হাইড করে রাখা হয়।
- এছাড়াও কোনো রাউট খুঁজে না পাওয়া গেলে তার জন্য `notFound` মিডলওয়্যার সেট করা আছে।

---

### ৬. Node-Cron বা ব্যাকগ্রাউন্ড টাস্ক নিয়ে কোনো রিস্ক আছে কি?

**প্রশ্ন:** আপনার `viewSyncJob` যদি কোনো কারণে ফেল করে, তবে কী হবে?

**উত্তর:** 
- আমি ট্রাই-ক্যাচ (`try-catch`) ব্লক ব্যবহার করেছি যাতে কোনো এরর হলেও পুরো অ্যাপ্লিকেশন ক্রাশ না করে। 
- **Reliability:** বর্তমান ইমপ্লিমেন্টেশনে আমি ডাটাবেসে সফলভাবে আপডেট হওয়ার পরই কেবল Redis থেকে কী (Key) ডিলিট করি। যদি কোনো একটি ডাটাবেস আপডেট ফেল করে, তবে সেই ডাটা Redis-এ থেকে যায় এবং পরবর্তী ৫ মিনিট পর আবার ট্রাই করা হয়। এটি ডাটা লস (Data Loss) রোধ করে।
- এটি নিশ্চিত করে যে ভারী কাজগুলো মেইন রিকোয়েস্ট-রেসপন্স সাইকেলের বাইরে হচ্ছে, ফলে ইউজার কোনো ল্যাগ ফিল করে না।

---

### ৭. ক্যাটাগরি এবং আর্টিকেলের মধ্যে সম্পর্ক কীভাবে মেইনটেইন করছেন?

**প্রশ্ন:** আর্টিকেল মডেলে `categoryId` কেন `ObjectId` হিসেবে রেখেছেন?

**উত্তর:** 
এটি MongoDB-র `Reference` পদ্ধতি। `populate()` ফাংশন ব্যবহার করে আমি কুয়েরি করার সময় ক্যাটাগরির বিস্তারিত তথ্য (নাম, স্লাগ) নিয়ে আসতে পারি। এটি ডাটাবেসে ডুপ্লিকেশন কমায় (Normalization) এবং ডাটা কনসিস্টেন্সি বজায় রাখে।

---

### বোনাস প্রশ্ন: সিকিউরিটি এবং ইনপুট ভ্যালিডেশন

**প্রশ্ন:** আপনার এই সিস্টেমে সিকিউরিটি বাড়ানোর জন্য আর কী কী করা যেতে পারে?
**উত্তর:**
- **JWT Authentication:** অ্যাডমিন প্যানেলের জন্য।
- **Input Validation:** `Joi` বা `express-validator` ব্যবহার করে রিকোয়েস্ট ডাটা ভ্যালিডেশন।
- **Rate Limiting:** ব্রুট ফোর্স অ্যাটাক ঠেকানোর জন্য।
- **Sanitization:** `XSS` অ্যাটাক থেকে বাঁচার জন্য কনটেন্ট স্যানিটাইজ করা।
